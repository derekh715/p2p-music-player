# CSCI3280 Peer to Peer Music Player Project

This README specifies the steps for compilation. For the description of
features, please refer to the report.

## Steps for Compilation

There are two ways to compile the program. The first way is using CMake, and
the second way is manual compilation with `g++`. The instructions for building
with CMake is provided below.

In this project there is a `CMakeLists.txt` which orchestrates the compilation.
Before you generate the build files, please make sure the following libraries
are present:

- `gtkmm3.0`: GTK+ bindings for C++, version 3. Any minor version should work.
- `gstreamer`, `gstreamer-app`, `gstreamer-video`, `gstreamer-audio`:
  `gstreamer` library with plugins. The versions are specified in the
  `CMakeLists.txt` file.
- `taglib`: handling audio metadata
- `sqlite3`: for file database
- `SQLiteCpp`: C++ wrapper for sqlite3
- `asio`: For asynchronous TCP/IP connections
- `googletest`: for testing

`googletest` and `SQLiteCpp` will be pulled from their
GitHub repository automatically. There is no need to install that library
beforehand.

If you choose to compile the program yourself, `SQLiteCpp`'s sources can be
fetched from [this repository](https://github.com/SRombauts/SQLiteCpp).

1. Clone the repository

2. Make sure you are at the **root** of the repository. The configuration for
   building the files can be generated by the following command:

```sh
cmake -B build -S src -DCMAKE_EXPORT_COMPILE_COMMANDS=1
```

- `-B` is for the directory where the executables, cache files etc will live.
- `-S` is the source directory where `CMakeLists.txt` and other source files will live.
- `-D` defines variables. `CMAKE_EXPORT_COMPILE_COMMANDS` specifies that a
`compile_commands.json` should be generated so that language servers how to find
the library headers. This is not required if you don't have these services in
the text editor.

This command only needs to run after `CMakeLists.txt` is changed (to regenerate
the build configuration files).

3. Compile the files with

```sh
cmake --build build [--config <Debug or Release>]
```

This builds the project. The `--config` flag may be needed for some build
systems (Visual Studio?). CMake places the executable in the `build` folder.

4. Run the program

```sh
./build/MusicSharing
```

## Special Note for Manual Compilation

For manual compilation, make sure `network-example.cpp`, `main.cpp` and
`BufferedAudioTest.cpp` are not compiled together. They all have a main entry
point.

## Image Interleaving

The image interleaving part is in `network-example.cpp`, but not in the GUI. It
uses the exact same algorithm for sharing audio (by dividing the file into equal
chunks, the report has more details). The executable built is called `interleave`,
upon execution the interface should look like this:

```
$ ./build/interleave 2000
Select one of the options
A) Connect to an IP
B) Ping a machine with peer_id
C) Ping all machines
D) Print all connected peers
E) Ask for track
F) Ask for lyrics
G) Ask for the interleaving images
H) Ask for the database of a client
I) Ask for a file
Q) Quit
```

To verify that image interleaving works, you can spawn multiple instances of
this program, and connect to them one by one. For example, if we have four
instances of port `2000`, `2001`, `2002` and `2003`. We can do the following
steps:

1. Press `a` to input IP and port:
```
a
Enter a hostname (enter 'l' for localhost)
l
Enter service / port: (this is a number)
2001
```

Do this for `2001`, `2002` and `2003`.

2. Start asking for interleaving images at port `2000` by pressing `g`

Messages with start appear. Eventually the output stream closes, signalling that
the file transfer is finished. To quit the program, press `q`.

3. View the interleave image `interleaved.bmp`.
